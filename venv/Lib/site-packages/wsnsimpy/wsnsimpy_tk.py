import sys
import os
from . import wsnsimpy 
from .wsnsimpy import BROADCAST_ADDR, start_delayed, ensure_generator
from threading import Thread
from .topovis import Scene, LineStyle
from .topovis.TkPlotter import Plotter

###########################################################
class Node(wsnsimpy.Node):
    """Custom Node class with enhanced visualization capabilities."""

    ###################
    def __init__(self, sim, id, pos):
        """Initialize the Node with simulation, ID, and position."""
        super().__init__(sim, id, pos)
        self.scene = self.sim.scene
        self.scene.node(id, *pos)  # Add the node to the scene for visualization

    ###################
    def send(self, dest, *args, **kwargs):
        """Send a message to the destination node with visualization."""
        # Visualize the transmission range
        obj_id = self.scene.circle(
            self.pos[0], self.pos[1],
            self.tx_range,
            line="wsnsimpy:tx")
        super().send(dest, *args, **kwargs)  # Call the send method of the parent class
        # Remove the transmission circle after a delay
        self.delayed_exec(0.2, self.scene.delshape, obj_id)
        if dest is not wsnsimpy.BROADCAST_ADDR:
            destPos = self.sim.nodes[dest].pos
            # Visualize the unicast line
            obj_id = self.scene.line(
                self.pos[0], self.pos[1],
                destPos[0], destPos[1],
                line="wsnsimpy:unicast")
            # Remove the unicast line after a delay
            self.delayed_exec(0.2, self.scene.delshape, obj_id)

    ###################
    def move(self, x, y):
        """Move the node to a new position with visualization."""
        super().move(x, y)
        self.scene.nodemove(self.id, x, y)  # Update the node's position in the scene


###########################################################
class DefaultPhyLayer(wsnsimpy.DefaultPhyLayer):
    """Physical layer class with enhanced visualization for transmission and collisions."""

    def on_tx_start(self, pdu):
        """Handle the start of a transmission."""
        super().on_tx_start(pdu)
        linetype = "wsnsimpy:ack" if pdu.type == "ack" else "wsnsimpy:tx"
        x, y = self.node.pos
        tx_time = pdu.nbits / self.bitrate
        oid = self.node.scene.circle(x, y, self.node.tx_range, line=linetype)
        self.node.delayed_exec(max(tx_time, 0.2), self.node.scene.delshape, oid)

    def on_collision(self, pdu):
        """Handle a collision event."""
        super().on_collision(pdu)
        x, y = self.node.pos
        # Visualize collision with a red 'X' mark
        line1 = self.node.scene.line(x-5, y-5, x+5, y+5, line="wsnsimpy:collision")
        line2 = self.node.scene.line(x+5, y-5, x-5, y+5, line="wsnsimpy:collision")
        self.node.delayed_exec(0.2, self.node.scene.delshape, line1)
        self.node.delayed_exec(0.2, self.node.scene.delshape, line2)


###########################################################
class DefaultMacLayer(wsnsimpy.DefaultMacLayer):
    """MAC layer class with enhanced visualization for unicast messages."""

    def on_receive_pdu(self, pdu):
        """Handle the reception of a PDU."""
        super().on_receive_pdu(pdu)
        if pdu.type != "data" or pdu.dst != self.node.id:
            return
        sx, sy = self.node.sim.nodes[pdu.src].pos
        dx, dy = self.node.pos
        oid = self.node.scene.line(sx, sy, dx, dy, line="wsnsimpy:unicast")
        self.node.delayed_exec(0.2, self.node.scene.delshape, oid)

###########################################################
class DefaultNetLayer(wsnsimpy.DefaultNetLayer):
    """Default network layer class (placeholder for custom implementation)."""
    pass

###########################################################
class LayeredNode(wsnsimpy.LayeredNode):
    """Node class with layered architecture (PHY, MAC, NET layers)."""

    ###################
    def __init__(self, sim, id, pos):
        """Initialize the layered node with default layers."""
        super().__init__(sim, id, pos)
        self.scene = self.sim.scene
        self.scene.node(id, *pos)
        # Set default layers for the node
        self.set_layers(
            phy=DefaultPhyLayer,
            mac=DefaultMacLayer,
            net=DefaultNetLayer)

    ###################
    def move(self, x, y):
        """Move the node to a new position with visualization."""
        super().move(x, y)
        self.scene.nodemove(self.id, x, y)

###########################################################
class _FakeScene:
    """Fake Scene class to handle cases when visualization is disabled."""

    def _fake_method(self, *args, **kwargs):
        """Placeholder method for scene operations."""
        pass

    def __getattr__(self, name):
        """Return the fake method for any attribute."""
        return self._fake_method

###########################################################
class Simulator(wsnsimpy.Simulator):
    '''Wrap WsnSimPy's Simulator class so that Tk main loop can be started in the main thread'''

    def __init__(self, until, timescale=1, terrain_size=(500, 500), visual=True, title=None):
        """Initialize the simulator with visualization options."""
        super().__init__(until, timescale)
        self.visual = visual
        self.terrain_size = terrain_size
        if self.visual:
            self.scene = Scene(realtime=True)
            # Define line styles for different events
            self.scene.linestyle("wsnsimpy:tx", color=(0, 0, 1), dash=(5, 5)) # Blue color for transmission
            self.scene.linestyle("wsnsimpy:ack", color=(0, 1, 1), dash=(5, 5)) # Cyan color for ACK
            self.scene.linestyle("wsnsimpy:unicast", color=(0, 0, 1), width=3, arrow='head') # Blue color for unicast
            self.scene.linestyle("wsnsimpy:collision", color=(1, 0, 0), width=3) # Red color for collision
            if title is None:
                title = "WsnSimPy"
            self.tkplot = Plotter(windowTitle=title, terrain_size=terrain_size)
            self.tk = self.tkplot.tk
            self.scene.addPlotter(self.tkplot)
            self.scene.init(*terrain_size)
        else:
            self.scene = _FakeScene()

    def init(self):
        """Initialize the simulator."""
        super().init()

    def _update_time(self):
        """Update the scene time periodically."""
        while True:
            self.scene.setTime(self.now)
            yield self.timeout(0.1)

    def run(self):
        """Run the simulator with optional visualization."""
        if self.visual:
            self.env.process(self._update_time())
            thr = Thread(target=super().run)
            thr.setDaemon(True)
            thr.start()
            self.tkplot.tk.mainloop()
        else:
            super().run()
